Learned from MongoDB University course : MongoDB Basics.

connecting to class cluster from mongo shell:
```
```

### What is MongoDB ?
A useful flexible database more flexible than SQL but more structured than Redis.

#### Mongo Compass/Robomongo
UI for seeing mongodb

#### Mongo Atlas
Mongos Db as a service


### Setting up mLab

1. Login with your account on website.
2. Create new database deployment with free tier.
3. Create a user + pwd for that database deployment.
4. now we have the URI, which can be used in our app.

#### Basic terminology

1. collection = table
2. record = document in a collection

#### Interesting observations

fields can have more than one type of data
e.g. 
for a movie document,
director can be string, array of strings or undefined.

Every document has a field named _id.

Fields can have scalar values and documents/records as values. i.e. fields can have values of type Array and Object For such fields, compass will show Document type and can expand.

What above means is that there can be documents in field of documents.
Contrast this with SQL where we usually referred to nested document only via a foreign key/id, whereas MongoDB has nesting/embedding of documents inside documents.

Because Mongo is flexible,
All documents don't need to have same fields,
as we have known some of the data might be missing in
case those fields will have value undefined.

One can arbitrarily mix, nest Array and documents like in JSON.

Mongo compass value graph view and value types view are useful for getting insights on possible values/types of fields and for data cleaning/migration etc.


#### MongoDB connection URI format

https://docs.mongodb.com/manual/reference/connection-string/


#### Filter/querying Mongo Data

When using compass, value graph provides useful click/drag/select and point interface for making queries automatically/ also which is a useful to learn query language early on.

Also another interesting observation: when a field has many values of given type e.g. year, it makes classes in such a way that they can be conviniently displayed in interface. e.g. 5 year or 10 year durations. 1995-2000 etc.
In these cases, if you want data for particular year, just write the query directly.

Filter query language is a json syntax defined by mongo.

#### Mongo clusters

Cluster has one primary and multiple secondaries.
For any cluster there is one and only one primary.
Only primary will accept writes.


#### Mongo Shell

Mongo shell is a fully functional javscript interpreter, kind of like node repl (https://docs.mongodb.com/manual/tutorial/write-scripts-for-the-mongo-shell/)

Also you can use tab completion in mongo shell to prevent incorrect commands/queries etc.

```
show dbs                  #show all databses
use dbName                #select a given dbName
db                        #db refers to currently selected database
show collections          #show collections in current db
```

In windows start mongo server/daemon using mongod.exe, put MongoDB/bin in PATH,
and use 
``` sh
mongod // to start server
mongo // to start client shell
```

#### Mongo CRUD operation concepts

All documents in mongodb must contain an _id field of type ObjectId (if autogenerated _id)
All _id within a given collection are unique (no guarantees of global uniqueness though)

* Creating Documents/rows:
 
  If you do insert on collection that does not exist, that collection will be created for you.
  e.g. Assume myMovies collection does not exist. and we issue command
  ```
    db.myMovies.insertOne({ title: "Star Trek II: The Wrath of Khan", year: 1982, imdb: "tt0084726"})
  ```
  Then myMovies collection will be created automatically.

  ##### Insert commands/functions

For every document added to collection, mongodb adds an _id key and the value is a corresponding ObjectID('adjflajfiew32lfjksdf23r') like value

  1. insertOne(documentObjectJSON) - It is a method on the collection class. and inserts single doucment corresponding to given JSON inside the collection.
  ```
  db.moviesScratch.insertOne({ title: "Star Trek II: The Wrath of Khan", year: 1982, imdb: "tt0084726"})
  ```

  2. insertMany(arrayJSON, optional optionsObjectJSON) - In many cases we want to insert more than one (bulkInsert) documents/rows into our collection/table.
    
    * Types of bulk inserts - Ordered inserts(default) and unordered inserts.
      * Ordered Inserts - Documents are inserted in order present in given array (in sequence) and document insertion stops once an error is encountered.
      e.g.
      ```
      db.moviesScratch.insertMany(
        [
          {
	          "_id" : "tt0084726",
	          "title" : "Star Trek II: The Wrath of Khan",
	          "year" : 1982,
	          "type" : "movie"
          },
          {
	          "_id" : "tt0796366",
	          "title" : "Star Trek",
	          "year" : 2009,
	          "type" : "movie"
          },
          {
            "_id" : "tt0084726",
            "title" : "Star Trek II: The Wrath of Khan",
            "year" : 1982,
            "type" : "movie"
          },
          {
            "_id" : "tt1408101",
            "title" : "Star Trek Into Darkness",
            "year" : 2013,
            "type" : "movie"
          },
          {
            "_id" : "tt0117731",
            "title" : "Star Trek: First Contact",
            "year" : 1996,
            "type" : "movie"
          }
        ]
      );
      ```
      * Unordered Inserts - Documents are inserted irrespective of order and error documents are not inserted, all other doucments are inserted. specified using providing options json along with array of documents.
      e.g.
      ```
      db.myMovies.insertMany(
        [
          {
	          "_id" : "tt0084726",
	          "title" : "Star Trek II: The Wrath of Khan",
	          "year" : 1982,
	          "type" : "movie"
          },
          {
            "_id" : "tt0796366",
            "title" : "Star Trek",
            "year" : 2009,
            "type" : "movie"
          },
          {
            "_id" : "tt0084726",
            "title" : "Star Trek II: The Wrath of Khan",
            "year" : 1982,
            "type" : "movie"
          },
          {
            "_id" : "tt1408101",
            "title" : "Star Trek Into Darkness",
            "year" : 2013,
            "type" : "movie"
          },
          {
            "_id" : "tt0117731",
            "title" : "Star Trek: First Contact",
            "year" : 1996,
            "type" : "movie"
          }
        ],
        {
	        ordered: false
        }
      );
      ```


  ##### Read/query commands and functions -> find

  In mongo shell, keys that require dot notation must be enclosed in quotes.

  find returns cursor of list of documents matching the given selection filters.

  * find(queryObjectJSON) - query object json contains key value pairs where they act as selectors, i.e. keys are fields we are interested in, and values are the values of the fields that we are interested in.

  e.g.
  ```
  db.movies.find({ "mpaaRating": "PG-13", year: 2009 });
  ```
  For querying of nested fields, use dot notation (string field names together using dot notation) for embedded documents.
  e.g.
  ```
  db.data.find({ "wind.direction.angle": 290 });
  ```

  Matching for array fields: 
  1. Literal matching: we provide exact array we want to match.
  2. Item matching: we provide item, and query returns all docs arrays that contain that items.
  3. Positional matching: we provide exact position and item in array we want to match.

  e.g. For e.g. cast in movie is usually a field whose value is array of strings

#### Sorting

* `Cursor based sort`:

The query results in a cursor which has a method `.sort` on it, hence `cursor.sort({ fieldName: -1 })` sorts by fieldName in descending order and `cursor.sort({ fieldName: 1 })` sorts by fieldName in ascending order.

#### BSON
BSON stands for binary JSON,
It is lightweight, traversable and efficient.
BSON extends JSON value types, to add double, byte, dates etc.
Take a look at the spec at BSONspec.org

### Mongoose Concepts

#### Schema
 In mongoose, you have to define your schema structure. There has to be a fixed schema.
The Schema allows you to define the fields stored in each document along with their validation requirements and default values.

#### Documents

Mongoose documents represent a one-to-one mapping to documents as stored in MongoDB. Each document is an instance of its Model.

#### Model
A model is a compiled schema used to instantiate documents of the particular structure.

The model represents collection of documents in the database that you can search, while the model's instances represent individual documents that you can save and retrieve.

The first argument is the singular name of the collection your model is for. Mongoose automatically looks for the plural version of your model name. Thus, for the example above, the model Tank is for the tanks collection in the database. The .model() function makes a copy of schema. Make sure that you've added everything you want to schema before calling .model()!
``` js
var schema = new mongoose.Schema({ name: 'string', size: 'string' });
// Tank model means tanks collection
var Tank = mongoose.model('Tank', schema);
```

Mongoose schema field types: String, Number, Boolean,
Array, Buffer, Date, ObjectId,
Mixed.

#### Code conventions

It is good idea to have one model + corresponding schema as a file and export
model.

``` js
// File: ./models/somemodel.js
//Require Mongoose
var mongoose = require('mongoose');
//Define a schema, which is local to file
var Schema = mongoose.Schema;
var SomeModelSchema = new Schema({
    a_string          : String,
    a_date            : Date,
});

//Export function to create "SomeModel" model class
module.exports = mongoose.model('SomeModel', SomeModelSchema );
```

#### Mongoose Virtuals

Mongoose virtuals are properties that can be get or set, but are not persisted to database.
Usually they are useful for derived data from db data. e.g. 
``` js
// virtual property fullName not in db but useful in code.
personSchema.virtual('fullName').get(function () {
  return this.name.first + ' ' + this.name.last;
});
```

#### Foreign keys in mongoose schemas using 'ref'

In a mongoose schema use a `type: ObjectId` with `ref: 'ModelName'` to point to entity in
a different model. The ref tells mongoose which model to use for objectId.
e.g.
``` js
var BookSchema = new Schema({
  title: {type: String, required: true},
  author: {type: Schema.ObjectId, ref: 'Author', required: true},
  summary: {type: String, required: true},
  isbn: {type: String, required: true},
  genre: [{type: Schema.ObjectId, ref: 'Genre'}]
});
```

Should look up into population: 
http://mongoosejs.com/docs/populate.html

#### Mongoose Validation

Mongoose provides built-in and custom validators, and synchronous and asynchronous validators. It allows you to specify both the acceptable range or values and the error message for validation failure in all cases

#### Querying data in js using mongoose

https://stackoverflow.com/questions/31549857/mongoose-what-does-the-exec-function-do

There are multiple ways to make fetch execution via mongoose.
When we make a query, it by default is lazy and will not be fetched unless told to do so.
Below are the three equivalent ways to fetch data from mongodb given query.
``` js
query.exec(nodeback);
// same as
query.then(result => console.log(result));
// same as
const result = await query;
```

Calling exec without argument returns a promise.
Also if one uses then/await on a query, 
the query is a thenable and follows appropriately.

### Mongoose instance methods.

Remember that instances of models are documents.
Documents have some built in methods like `save` etc.

But we can add our on methods on instances using `abcSchema.methods.doSomething = () => {}`

```js
// methods lies on schema
userSchema.methods.doingSomething = function(cb) {
  console.log(this); // inside function this is the document
  cb();// go back
}
```