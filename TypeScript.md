
### Webpack with typescript

https://webpack.js.org/guides/typescript/#basic-setup

### Basics
Typescript is an os-level install usually since it is a compiler, so installed by `npm install -g typescript` flag, and does not appear in project dependencies.

But it is also a good idea to package with your app as a development dependency with `--save-dev`.

**Note** - when using typescript with webpack it is better idea to keep a local copy of typescript, also webpack uses typescript-loader to do the work.

Use //ts-check
for type checking in any file.

### Role of tsconfig.json

It is a configuration file generated by `tsc --init`.
It tells typescript how your project is supposed to be processed.

### A crude way to bundle .ts files together

```sh
tsc --outfile bundle.js f1.ts f2.ts f3.ts // order matters
```

### linting

`TSlint` is deprecated.
https://typescript-eslint.io/docs/linting/tslint

prefer `eslint` with typescrpt parser i.e typescript-eslint project

### Useful tsconfig options

* `strictNullChecks` - Usually keep this true to keep all types seperate, If you want a variable to hold null value, you will have to explicitly specify it in type.

* `strictPropertyInitialization` - 2.7 onwards available, warns for uninitialized variables.

* `noEmitOnError` - If typescript error is found, i.e. compiler reports an error, code is not compiled. i.e. js files are not created.

* `sourceMap` - setting this to true creates .js.map files along with .js, helping us in debugging ts code as well.

* `noImplicityAny` - If set to true, will set type of unininitialized variables implicitly to "any".

### What to compile ?

1. explicitly specify via `files`: telling to compile only given list.

2. `exclude`: compile everything except what is present in exclude value.

**Note** - when compiling a single file specified at sh/cmd e.g. `tsc app.ts` instead of `tsc`, the tsconfig.json does not come into picture, you have to use command line flags to achieve a similar effect.

### Integration with webpack

1. `at-loader`: also known as Awesome typescript loader (a compile time dep.)
2. `ts-loader`: Default typescript loader.

`source-map-loader` is also needed.

### In what ways can a type be introduced?

If you’re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a type is introduced with:

1. A type alias declaration (`type sn = number | string;`)
2. An interface declaration (`interface I { x: number[]; }`)
3. A class declaration (`class C { }`)
4. An enum declaration (`enum E { A, B, C }`)
5. An `import` declaration which refers to a type

### In what ways are values introduced ?

Again, being explicit, the following things create values:

1. let, const, and var declarations
2. A namespace or module declaration which contains a value
3. An enum declaration
4. A class declaration
5. An import declaration which refers to a value
6. A function declaration

### one name multiple meanings!

One name, multiple meanings
Given a name A, we might find up to three different meanings for A: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration 
```ts
let m: A.A = A;
```
A is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations

### What are typescript definition files `*.d.ts` ?

They allow you to provide type information for JavaScript code that is by itself (by its very nature) not statically typed. The file extension for such a file is .d.ts, where d stands for definition. Type definition files make it possible to enjoy the benefits of type checking, autocompletion, and member documentation

Typescript definition files i.e. `filename.d.ts` are typically a translation layer between simple Javsascript library/projects without types to an interface that provides types to the user of the library.
 Helps IDEs and language services with autocompletion and type checking.
 The repository DefinitelyTyped on github contains typescript definition files for all well known projects.

 When a TypeScript script gets compiled there is an option to generate a declaration file (with the extension .d.ts) that functions as an interface to the components in the compiled JavaScript. In the process the compiler strips away all function and method bodies and preserves only the signatures of the types that are exported. The resulting declaration file can then be used to describe the exported virtual TypeScript types of a JavaScript library or module when a third-party developer consumes it from TypeScript.

 Find everything at https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html

### @types - npm level access to definitely typed repo
used post-2.0 typescript, save types as a dependency, ends up in node_modules.
`npm install --save-dev @types/jquery`

### typings - the types package manager
Used pre-2.0 typescript
`typings install` installs types in a `typings` folder at project level dir.
`typings.json` is the config file for type management.

### How type-checkers usually work

They start with values/atoms like numbers, strings booleans  etc. and operations like *, + etc. and flow the types into variables in such a way that a constraint satisfaction problem is solved, and the most general type is given to variables that are not directly connected to values.

### Function types

All function types require parameter names instead of just
types. ie.e.
```ts
// let kk: number => number; // syntax Error
let kk: (a: number) => number = function(x){ return 0 }; // correct
```

We make it clear which is the return type by using a fat arrow (=>) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn’t return a value, you would use void instead of leaving it off.

```ts
// types with function declaration allow colon
let myAdd = function(x: number, y: number): number { return  x + y; };
```

**Interfaces** are also capable of defining function types:
This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.
```ts
interface SearchFunc {
    (source: string, subString: string): boolean;// notice no name given to fn signature, so interface is fn type
}
// equivalent to
type SearchFunc = (source: string, subString: string) => boolean;
```

### Typescript `as` keyword and prefix casting

```ts
var x = <any> foo;// the cast is a prefix
// is equivalent to:
var x = foo as any;// useful in .tsx files
```

### `extends` keyword in generics

Use `extends` and `subtype of` interchangably.
i.e. `<T extends U>` indicates T is a subtype of U,
Or A variable of Type `T` is `assiabnable to` a variable of type `U`.
i.e. 
`<T extends Animal>` stands for a variable of type `T` is assignable to a variable of type `Animal`. e.g. A variable of type `Cat` is assignable to a variable of type `Animal` so `<T extends Animal>` is satisfied by `T = Cat`.

Or in other words `Cat < Animal` i.e. Cat is subtype of Animal and fits `T extends Animal`.

### Typescript "declare" keyword

var creates a new variable. declare is used to tell TypeScript that the variable has been created elsewhere. If you use declare, nothing is added to the JavaScript that is generated - it is simply a hint to the compiler.

For example, if you use an external script that defines var externalModule, you would use declare var externalModule to hint to the TypeScript compiler that externalModule has already been set up

### The double life of `typeof` operator in Typescript

The `typeof` operator always takes in a value,
but executes differently depending on the expression it is used in.

In case a value expression is required it returns good ol' "object" or "function" or primitive types.

In case a type expression is required it returns a more expressive type.

e.g.
```ts
let aval = {
    a: "hi", b: 2
};
console.log(typeof aval); // object
// typeof behaves differently in a type-expression
type at = typeof aval;// at = { a: string; b: number }

let bar = {a: 0};
let TypeofBar = typeof bar; // the value "object"
type TypeofBar = typeof bar; // the type {a: number}

function Tutu() { return 1; }
let yy = typeof Tutu;// function
console.log(yy); //function
type tt =  typeof Tutu;// tt = () => number
```

### The double life of `class` keyword in Typescript

When declaring a class, we introduce a constructor in the value namespace, so that it would be used with `new`.

But it is also declared as a type in the type namespace that can be used as type of all the instances of the class.

Using `typeof` on a `class`:

“give me the type of the symbol called Greeter” which is the type of the constructor function. This type will contain all of the static members(prototype functions etc also) of Greeter along with the constructor that creates instances of the Greeter class.
```ts
class Greeter {
    static standardGreeting = "Hello, there";
    greeting: string;
    greet() {
        if (this.greeting) {
            return "Hello, " + this.greeting;
        }
        else {
            return Greeter.standardGreeting;
        }
    }
}

let greeter1: Greeter;// type of instance is class name
greeter1 = new Greeter();
console.log(greeter1.greet());

let greeterMaker: typeof Greeter = Greeter;
greeterMaker.standardGreeting = "Hey there!";

let greeter2: Greeter = new greeterMaker();
console.log(greeter2.greet());
```

**Note**: Class(constructor function) are structurally typed in Typescript:
```ts
class MyClass {
  method(val: number) { /* ... */ }
}

class YourClass {
  method(val: number) { /* ... */ }
}

let test1: typeof MyClass = YourClass; // Works!
let test2: typeof MyClass = MyClass;   // Works!
```

#### Parameter properties and intialization with declaration

Parameter property with `name` property,
will help us omit the line `this.name = 8` in constructor
```ts
class Octopus {
    readonly numberOfLegs: number = 8;
    constructor(readonly name: string) {
    }
}

class Person {
    // no need to write this.name = name
    constructor(public name: string) {}
}

var p = new Person("wow");
console.log(p.name);// wow
```

### Object type

Some functions in javascript would not expect primitive types,
but only object of any kind.
In that cases `object` type should be used.
There is another type `Object`

### Making properties and objects immutable
**Note**: all protection is compile time

1. `readonly` keyword
2. `ReadonlyArray<String>` for Arrays etc.
It works like this
```ts
interface ReadonlyArray<T> {
    /// bunch of stuff
    // do not expose methods like push/splice which mutate array
    readonly length: number;
    readonly [n: number]: T;
}
```
3. we can make our own immutable objects/classes using technique above

### Gotchas

* excess property checks with object literals
Object literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error(object literal may specify only known properties)

* All things are structurally typed

Here is a big disucussion thread on github for nominal type support.
https://github.com/Microsoft/TypeScript/issues/202#issuecomment-329914167

* Modules

In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module. Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).

### String index signatures

here we’re saying a SquareConfig can have any number of properties, and as long as they aren’t color or width, their types don’t matter.

```ts
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

### Covariance and Contravariance

https://dmitripavlutin.com/typescript-covariance-contravariance/

### Exhaustive checking with `never` type

`never` type represents something which is unreachable.
E.g. a funciton that always throws or is in an infinite loop
has a return type of never.

A switch case which covers all possible input also has `never` type 
in the default case.

```ts
type size = "L" | "M" |"S";

function neverAssertion(a: never): never{
    throw new Error(" a should be never but it is " + a);
}

function checkSizes(s: size) {
    switch(s) {
        case "L": return 10;
        case "M": return 20;
        // case "S": return 30;
        default: neverAssertion(s);// type error here until all cases of size are covered
    }
}
```

### Type Guards

A type guard is some expression that performs a runtime check that guarantees the type in some scope. Like narrowing of types in certain blocks of code, via control flow analysis.

narrowing of types using type guards is useful for handling multiple cases in union type.

#### User defined type guards

1. `type predicates`: We provide hint to compiler 
about type of a argument passed into a predicate function.

e.g.
```ts
// isFish is a type guard
// which when satisfied hints compiler that
// type is Fish inside type guarded block
function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;// some cast + compare property against undefined is required
}
```

2. `typeof` guard: `typeof` operator acts as a guard
by itself.
```ts
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        // padding is number here
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        // padding is string here
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
```

3. While typeof takes a string as argument and works on primitive types,
`instanceof` works with constructor functions(**not type or interfaces**)

`instanceof` tests whether prototype property of a constructor 
appears somewhere in the prototype chain of an object.


```ts
interface Paddable {
    getPadding(): string;
}

class ABCElement implements Paddable {
    getPadding(){
        return "10";
    }
}

function testSomething(el: Paddable | string) {
    if (el instanceOf ABCElement) {
        // el  is ABCElement here
        console.log(el.getPadding());
    } else {
        // do something else
    }
}
```

### Sum types and sub-type constraints (extends)

A sumtype with a smaller list in union is a sub-type of a sumtype with larger 
list.

e.g. 
```ts
type sometype = "a"|"b"|"c"|"d";
type subtype = "a"|"b";

// then subtype extends sometype
// or subtype <: sometype
// or subtype is assignable to sometype
```

### Postfix exclamation operator (`identifier!`)

removes `null` and `undefined` from the type of identifier.
* Telling/Forcing the compiler that the I as a programmer know better.
e.g.
```js
function fixed(name: string | null): string {
  function postfix(epithet: string) {
    return name!.charAt(0) + '.  the ' + epithet; // ok
  }
  name = name || "Bob";
  return postfix("great");
}
```
Useful in cases of nested function where calls could not be tracked.



### Enums

Enums are probably the most useful feature needed
e.g.
```ts
enum MediaType {
    JSON = 'application/json',
    HTML = 'text/html'
}

let mt: MediaType = MediaType.HTML;
```

`const enum` compiles differently (removes json object altogether and makes value inline in compiled version) than regular `enum`(preserves mapping).
There is also a compiler option `preserveConstEnums` to control this.

### Function signature overloads

### TS "in" operator type guard since 2.7

Using the JavaScript “in” operator, we can test for the presence of different properties on the argument object, and TypeScript will automatically infer the exact type of our object in that block.

```ts
interface Admin{
    id: number;
    role: string;
}
interface User{
    email: string;
}

function doSomething(a: Admin | user) {
    if ("role" in a) { // a: Admin in this type guard
        console.log(a.id);
    } else {
        console.log(a.email); // a: User in this context
    }
}
```

### Interface vs `type`

One difference is that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for instance, **error messages/hovering won’t use the alias name**. In the code below, hovering over interface in an editor will show that it returns an Interface, but will show that aliased returns object literal type.

A second more important difference is that type aliases cannot be extended or implemented from (nor can they extend/implement other types)

`type` alias can name a primitive type, `interface` type cannot.
e.g.
```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;
```

Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:
```ts
type Container<T> = { value: T };
```

**Note: Type aliases and circular references**
 a type alias can refer to itself in a property, but not anywhere else on the right side of the declaration.
 ```ts
 type Foo = { x: Foo }// works
 type Bar<A> = { x: string }
 type Foo = Bar<Foo>; // Error! circular references
 ```

One can mimic intersection types made by `type` keyword using
`extends` in interfaces,
But it is not possible to make union interface by unioning two interfaces. One must use `type` keyword for unioning.

* An interface can extend a type as well as an interface (but an interface cannot extend a union type, compile time shape lockdown is necessary)

* **Declaration merging** - If two interfaces have same name, their properties will be merged together
```ts
interface Foo{
    a: string;
}
interface Foo{
    b: string;
}
// now Foo = {a: string; b: string; }
```
Publically extensible types in libraries should be interfaces.

### Literal types

Usually enums/disjoint union of values.
String literal types allow you to specify the exact value a string must have

### Discriminated Union/ Tagged Union types

Need `strictNullChecks` to be true, in order for this to work correctly.
The discriminant/tag should be a literal type, and it is a common property
to all the types, so that it is used to distinguish between them.

Three ingridients:
1. discrimintant : same/common property name, but different value in each of the types. (`kind` is good example of an artificial tag/discriminant that can be inserted into each type, but the value of kind has to be a literal type).
2. union: a union type of all the types
3. type guards on common property (discriminant)

e.g
```ts
// success is discriminant, result type is the union
type result = 
    | { success: true, value: number }
    | { success: false, error: string};

function processResult(res: result) {
    if (result.success) { // type narrows down on discriminant pattern match
        console.log(result.value);
    } else {
        console.log(result.error);
    }
}

// pattern matching is also a neat trick with discriminated unions
// where each one has a tag/discriminant, we can switch case by tag
// kind is the discriminant(has to beliteral), shape is the union
type shape =
    // kind is a literal type that is used as discriminating tag
    | { kind: "Triangle", b: number, h: number }
    | { kind: "Rectangle", sideA: number, sideB: number }
    | { kind: "Circle", radius: number }

function calculateArea(s: shape) {
    //switch(unionInstance.discriminant)
    switch(s.kind) {
        case "Triangle": // type narrows down on pattern match
            return 0.5 * s.b * s.h;
        case "Rectangle":
            return s.sideA * s.sideB;
        case "Circle":
            return Math.PI * s.radius * s.radius;
    }
}
```

### `keyof` and Lookup Types

`keyof SomeType` returns all property names of `SomeType` joined together as a union type.
e.g.
```ts
interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

function isKeyPresent(todo: Todo, key: keyof Todo) { // key: "id" | "text" | "completed"
    return todo[key];
}

// a commonly used idiom with generics
function <T, K keyof T> doSomething(obj: T, key: K) {
    return obj[key];
}
// return type is T[K] also known as Lookup type/ indexed access type
``` 

### Indexed types

`keyof` is known as index type query operator.

For any type `T`, `keyof T` is the union of known, public property names of `T`.

e.g.
```ts
let personProps: keyof Person; // 'name' | 'age'
```

The second operator is `T[K]`, the **indexed access operator**. Here, the type syntax reflects the expression syntax. That means that `person['name']` has the type `Person['name']` — which in our example is just `string`. However, just like index type queries, you can use `T[K]` in a generic context, which is where its real power comes to life. You just have to make sure that the type variable `K extends keyof T`.

#### Index types and string index signatures

```ts
interface Map<T> {
    [key: string]: T;// string index signature
}

var k : keyof Map<number>; // k: string
var j : Map<number>['foo']; // j: number
```

### Mapped types

Basically `[P in keyof T]` result in iteration of all properties `P` of interface/type/object `T`.

In essence, mapped types make use of `index type query operator` and
`index type access operator` to morph over all properties by iteration.

A transformation applied to all properties of a given type, resulting in a new type known as a mapped type.
Ann e.g. is ReadOnly.
```ts
// make all properties of input type
type ReadOnly<T> = {
    readonly [P in keyof T] : T[P]
}

// another exampl
type Nullable<T> = {
    [P in keyof T]: T[P] | null
};
```

**Partial** is a useful mapped type. Allow subset of properties
```ts
type Partial<T> = { [P in keyof T]?: T[P] }
type Person = { name: string; age: number; id: number; }
let k : Partial<Person> = { id: 223, name: 'chet' };
```
**But beware** Partial will not worn you over undefined access 
e.g. `k.age.toFixed(2)` will throw error above, but typescript will not warn.
So better use typeguards after introducing Partial.

### `Record` and `Pick` mapped types

Pick lets you pick `K` properties out of `T`.

```ts
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
}

let j: Pick<Person, 'name'| 'age'> = { name: 'dud', age: 4 };
```

**Record Type**
A `Record<K, T>` is an object type whose property keys are `K` and whose property values are `T`.
```ts

type Record<K extends string, T> = {
    [P in K]: T;
}

//NOte: K extends string can be satisfied by "A" | "B" | "C"

type ThreeStringProps = Record<'prop1' | 'prop2' | 'prop3', string>
Is it exactly the same as this?:

//equivalent
type ThreeStringProps2 = {prop1: string, prop2: string, prop3: string}

``` 

### Specifying type parameters in function call

Normally typescript will infer type-parameter automatically at function call site,
but in case it is not able to, one can explicitly specify type parameter at callsite as well.

```ts
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2);
}

const arr = combine([1, 2, 3], ["hello"]);
// Error: Type 'string' is not assignable to type 'number'.


// Fix: explicitly specify type parameter at callsite
const arr = combine<number | string>([1, 2, 3], ["hello"]);
```

### Conditional types

### `infer` keyword

