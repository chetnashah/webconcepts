
### Webpack with typescript

https://webpack.js.org/guides/typescript/#basic-setup

### Basics
Typescript is an os-level install usually since it is a compiler, so installed by `npm install -g typescript` flag, and does not appear in project dependencies.

But it is also a good idea to package with your app as a development dependency with `--save-dev`.

**Note** - when using typescript with webpack it is better idea to keep a local copy of typescript, also webpack uses typescript-loader to do the work.

Use //ts-check
for type checking in any file.

### Role of tsconfig.json

It is a configuration file generated by `tsc --init`.
It tells typescript how your project is supposed to be processed.

### A crude way to bundle .ts files together

```sh
tsc --outfile bundle.js f1.ts f2.ts f3.ts // order matters
```

### Useful tsconfig options

* strictNullChecks - Usually keep this true to keep all types seperate, If you want a variable to hold null value, you will have to explicitly specify it in type.

* noEmitOnError - If typescript error is found, i.e. compiler reports an error, code is not compiled. i.e. js files are not created.

* sourceMap - setting this to true creates .js.map files along with .js, helping us in debugging ts code as well.

* noImplicityAny - If set to true, will set type of unininitialized variables implicitly to "any".

### What to compile ?

1. explicitly specify via `files`: telling to compile only given list.

2. `exclude`: compile everything except what is present in exclude value.

**Note** - when compiling a single file specified at sh/cmd e.g. `tsc app.ts` instead of `tsc`, the tsconfig.json does not come into picture, you have to use command line flags to achieve a similar effect.

### Integration with webpack

1. `at-loader`: also known as Awesome typescript loader (a compile time dep.)
2. `ts-loader`: Default typescript loader.

`source-map-loader` is also needed.

### In what ways can a type be introduced?

If you’re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a type is introduced with:

1. A type alias declaration (`type sn = number | string;`)
2. An interface declaration (`interface I { x: number[]; }`)
3. A class declaration (`class C { }`)
4. An enum declaration (`enum E { A, B, C }`)
5. An `import` declaration which refers to a type

### In what ways are values introduced ?

Again, being explicit, the following things create values:

1. let, const, and var declarations
2. A namespace or module declaration which contains a value
3. An enum declaration
4. A class declaration
5. An import declaration which refers to a value
6. A function declaration

### one name multiple meanings!

One name, multiple meanings
Given a name A, we might find up to three different meanings for A: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration 
```ts
let m: A.A = A;
```
A is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations

### What are typescript definition files `*.d.ts` ?

They allow you to provide type information for JavaScript code that is by itself (by its very nature) not statically typed. The file extension for such a file is .d.ts, where d stands for definition. Type definition files make it possible to enjoy the benefits of type checking, autocompletion, and member documentation

Typescript definition files i.e. `filename.d.ts` are typically a translation layer between simple Javsascript library/projects without types to an interface that provides types to the user of the library.
 Helps IDEs and language services with autocompletion and type checking.
 The repository DefinitelyTyped on github contains typescript definition files for all well known projects.

 When a TypeScript script gets compiled there is an option to generate a declaration file (with the extension .d.ts) that functions as an interface to the components in the compiled JavaScript. In the process the compiler strips away all function and method bodies and preserves only the signatures of the types that are exported. The resulting declaration file can then be used to describe the exported virtual TypeScript types of a JavaScript library or module when a third-party developer consumes it from TypeScript.

 Find everything at https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html

### @types - npm level access to definitely typed repo
used post-2.0 typescript, save types as a dependency, ends up in node_modules.
`npm install --save-dev @types/jquery`

### typings - the types package manager
Used pre-2.0 typescript
`typings install` installs types in a `typings` folder at project level dir.
`typings.json` is the config file for type management.

### How type-checkers usually work

They start with values/atoms like numbers, strings booleans  etc. and operations like *, + etc. and flow the types into variables in such a way that a constraint satisfaction problem is solved, and the most general type is given to variables that are not directly connected to values.

### Function types

All function types require parameter names instead of just
types. ie.e.
```ts
// let kk: number => number; // syntax Error
let kk: (a: number) => number = function(x){ return 0 }; // correct
```

We make it clear which is the return type by using a fat arrow (=>) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn’t return a value, you would use void instead of leaving it off.

```ts
// types with function declaration allow colon
let myAdd = function(x: number, y: number): number { return  x + y; };
```

**Interfaces** are also capable of defining function types:
This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.
```ts
interface SearchFunc {
    (source: string, subString: string): boolean;
}
// equivalent to
type SearchFunc = (source: string, subString: string) => boolean;
```

### Typescript `as` keyword and prefix casting

```ts
var x = <any> foo;
// is equivalent to:
var x = foo as any;// useful in .tsx files
```

### Typescript "declare" keyword

var creates a new variable. declare is used to tell TypeScript that the variable has been created elsewhere. If you use declare, nothing is added to the JavaScript that is generated - it is simply a hint to the compiler.

For example, if you use an external script that defines var externalModule, you would use declare var externalModule to hint to the TypeScript compiler that externalModule has already been set up

### The double life of `typeof` operator in Typescript

The `typeof` operator always takes in a value,
but executes differently depending on the expression it is used in.

In case a value expression is required it returns good ol' "object" or "function" or primitive types.

In case a type expression is required it returns a more expressive type.

e.g.
```ts
let aval = {
    a: "hi", b: 2
};
console.log(typeof aval); // object
// typeof behaves differently in a type-expression
type at = typeof aval;// at = { a: string; b: number }

let bar = {a: 0};
let TypeofBar = typeof bar; // the value "object"
type TypeofBar = typeof bar; // the type {a: number}

function Tutu() { return 1; }
let yy = typeof Tutu;// function
console.log(yy); //function
type tt =  typeof Tutu;// tt = () => number
```

### The double life of `class` keyword in Typescript

When declaring a class, we introduce a constructor in the value namespace, so that it would be used with `new`.

But it is also declared as a type in the type namespace that can be used as type of all the instances of the class.

Using `typeof` on a `class`:

“give me the type of the symbol called Greeter” which is the type of the constructor function. This type will contain all of the static members(prototype functions etc also) of Greeter along with the constructor that creates instances of the Greeter class.
```ts
class Greeter {
    static standardGreeting = "Hello, there";
    greeting: string;
    greet() {
        if (this.greeting) {
            return "Hello, " + this.greeting;
        }
        else {
            return Greeter.standardGreeting;
        }
    }
}

let greeter1: Greeter;// type of instance is class name
greeter1 = new Greeter();
console.log(greeter1.greet());

let greeterMaker: typeof Greeter = Greeter;
greeterMaker.standardGreeting = "Hey there!";

let greeter2: Greeter = new greeterMaker();
console.log(greeter2.greet());
```

**Note**: Class(constructor function) are structurally typed in Typescript:
```ts
class MyClass {
  method(val: number) { /* ... */ }
}

class YourClass {
  method(val: number) { /* ... */ }
}

let test1: typeof MyClass = YourClass; // Works!
let test2: typeof MyClass = MyClass;   // Works!
```

### Object type

Some functions in javascript would not expect primitive types,
but only object of any kind.
In that cases `object` type should be used.
There is another type `Object`

### Making properties and objects immutable
**Note**: all protection is compile time

1. `readonly` keyword
2. `ReadonlyArray<String>` for Arrays etc.
It works like this
```ts
interface ReadonlyArray<T> {
    /// bunch of stuff
    // do not expose methods like push/splice which mutate array
    readonly length: number;
    readonly [n: number]: T;
}
```
3. we can make our own immutable objects/classes using technique above

### Gotchas

* excess property checks with object literals
Object literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error(object literal may specify only known properties)

* All things are structurally typed

Here is a big disucussion thread on github for nominal type support.
https://github.com/Microsoft/TypeScript/issues/202#issuecomment-329914167

* Modules

In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module. Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).

### String index signatures

here we’re saying a SquareConfig can have any number of properties, and as long as they aren’t color or width, their types don’t matter.

```ts
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

### Exhaustive checking with `never` type

`never` type represents something which is unreachable.
E.g. a funciton that always throws or is in an infinite loop
has a return type of never.

A switch case which covers all possible input also has `never` type 
in the default case.

```ts
type size = "L" | "M" |"S";

function neverAssertion(a: never): never{
    throw new Error(" a should be never but it is " + a);
}

function checkSizes(s: size) {
    switch(s) {
        case "L": return 10;
        case "M": return 20;
        // case "S": return 30;
        default: neverAssertion(s);// type error here until all cases of size are covered
    }
}
```

### Type Guards

A type guard is some expression that performs a runtime check that guarantees the type in some scope. Like narrowing of types in certain blocks of code, via control flow analysis.

#### User defined type guards

1. `type predicates`: We provide hint to compiler 
about type of a argument passed into a predicate function.

e.g.
```ts
// isFish is a type guard
// which when satisfied hints compiler that
// type is Fish inside type guarded block
function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;
}
```

2. `typeof` guard: `typeof` operator acts as a guard
by itself.
```ts
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        // padding is number here
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        // padding is string here
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
```

3. While typeof takes a string as argument and works on primitive types,
`instanceof` works with constructor functions(**not type or interfaces**)

```ts
interface Paddable {
    getPadding(): string;
}

class ABCElement implements Paddable {
    getPadding(){
        return "10";
    }
}

function testSomething(el: Paddable | string) {
    if (el instanceOf ABCElement) {
        // el  is ABCElement here
        console.log(el.getPadding());
    } else {
        // do something else
    }
}
```

### Enums

Enums are probably the most useful feature needed
e.g.
```ts
enum MediaType {
    JSON = 'application/json',
    HTML = 'text/html'
}

let mt: MediaType = MediaType.HTML;
```

`const enum` compiles differently (removes json object altogether and makes value inline in compiled version) than regular `enum`(preserves mapping).
There is also a compiler option `preserveConstEnums` to control this.

### Function signature overloads

### Interface vs `type`

One difference is that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for instance, error messages won’t use the alias name. In the code below, hovering over interfaced in an editor will show that it returns an Interface, but will show that aliased returns object literal type.

A second more important difference is that type aliases cannot be extended or implemented from (nor can they extend/implement other types)

### Literal types

Usually enums/disjoint union of values.
String literal types allow you to specify the exact value a string must have

### Discriminated Union/ Tagged Union types

Need `strictNullChecks` to be true, in order for this to work correctly.
The discriminant/tag should be a literal type, and it is a common property
to all the types, so that it is used to distinguish between them.

e.g
```ts
type result = 
    | { success: true, value: number }
    | { success: false, error: string};

function processResult(res: result) {
    if (result.success) { // type narrows down on discriminant pattern match
        console.log(result.value);
    } else {
        console.log(result.error);
    }
}

// pattern matching is also a neat trick with discriminated unions
// where each one has a tag, we can switch case by tag
type shape =
    // kind is a literal type that is used as discriminating tag
    | { kind: "Triangle", b: number, h: number }
    | { kind: "Rectangle", sideA: number, sideB: number }
    | { kind: "Circle", radius: number }

function calculateArea(s: shape) {
    switch(s.kind) {
        case "Triangle": // type narrows down on pattern match
            return 0.5 * s.b * s.h;
        case "Rectangle":
            return s.sideA * s.sideB;
        case "Circle":
            return Math.PI * s.radius * s.radius;
    }
}

```

### `keyof` and Lookup Types

`keyof SomeType` returns all property names of `SomeType` joined together
as a union type.
e.g.
```ts
interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

function isKeyPresent(todo: Todo, key: keyof Todo) { // key: "id" | "text" | "completed"
    return todo[key];
}

// a commonly used idiom with generics
function <T, K keyof T> doSomething(obj: T, key: K) {
    return obj[key];
}
// return type is T[K] also known as Lookup type/ indexed access type
``` 

### Indexed types

### Mapped types

A transformation applied to all properties of a given type, resulting in a new type known as a mapped type.
Ann e.g. is ReadOnly.
```ts
// make all properties of input type
type ReadOnly<T> = {
    readonly [P in keyof T] : T[P]
}

// another exampl
type Nullable<T> = {
    [P in keyof T]: T[P] | null
};
```

### Conditional types

