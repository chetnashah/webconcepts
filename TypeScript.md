
Typescript is an os-level install usually since it is a compiler, so installed by `npm install -g typescript` flag, and does not appear in project dependencies.

**Note** - when using typescript with webpack it is better idea to keep a local copy of typescript, also webpack uses typescript-loader to do the work.

Use //ts-check
for type checking in any file.

### Role of tsconfig.json

It is a configuration file generated by `tsc --init`.
It tells typescript how your project is supposed to be processed.

### A crude way to bundle .ts files together

```sh
tsc --outfile bundle.js f1.ts f2.ts f3.ts // order matters
```

### Useful tsconfig options

* strictNullChecks - Usually keep this true to keep all types seperate, If you want a variable to hold null value, you will have to explicitly specify it in type.

* noEmitOnError - If typescript error is found, i.e. compiler reports an error, code is not compiled. i.e. js files are not created.

* sourceMap - setting this to true creates .js.map files along with .js, helping us in debugging ts code as well.

* noImplicityAny - If set to true, will set type of unininitialized variables implicitly to "any".

### What to compile ?

1. explicitly specify via `files`: telling to compile only given list.

2. `exclude`: compile everything except what is present in exclude value.

**Note** - when compiling a single file specified at sh/cmd e.g. `tsc app.ts` instead of `tsc`, the tsconfig.json does not come into picture, you have to use command line flags to achieve a similar effect.

### What are typescript definition files ?

Typescript definition files i.e. `filename.d.ts` are typically a translation layer between simple Javsascript library/projects without types to an interface that provides types to the user of the library.
 Helps IDEs and language services with autocompletion and type checking.
 The repository DefinitelyTyped on github contains typescript definition files for all well known projects.

 Find everything at https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html

### @types - npm level access to definitely typed repo
used post-2.0 typescript, save types as a dependency, ends up in node_modules.
`npm install --save-dev @types/jquery`

### typings - the types package manager
Used pre-2.0 typescript
`typings install` installs types in a `typings` folder at project level dir.
`typings.json` is the config file for type management.

### How type-checkers usually work

They start with values/atoms like numbers, strings booleans  etc. and operations like *, + etc. and flow the types into variables in such a way that a constraint satisfaction problem is solved, and the most general type is given to variables that are not directly connected to values.

### Function types

All function types require parameter names instead of just
types. ie.e.
```ts
// let kk: number => number; // syntax Error
let kk: (a: number) => number = function(x){ return 0 }; // correct
```

We make it clear which is the return type by using a fat arrow (=>) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn’t return a value, you would use void instead of leaving it off.

```ts
// types with function declaration allow colon
let myAdd = function(x: number, y: number): number { return  x + y; };
```

**Interfaces** are also capable of defining function types:
This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.
```ts
interface SearchFunc {
    (source: string, subString: string): boolean;
}
// equivalent to
type SearchFunc = (source: string, subString: string) => boolean;
```

### Typescript "declare" keyword

var creates a new variable. declare is used to tell TypeScript that the variable has been created elsewhere. If you use declare, nothing is added to the JavaScript that is generated - it is simply a hint to the compiler.

For example, if you use an external script that defines var externalModule, you would use declare var externalModule to hint to the TypeScript compiler that externalModule has already been set up

### Object type

Some functions in javascript would not expect primitive types,
but only object of any kind.
In that cases `object` type should be used.
There is another type `Object`

### Making properties and objects immutable
**Note**: all protection is compile time

1. `readonly` keyword
2. `ReadonlyArray<String>` for Arrays etc.
It works like this
```ts
interface ReadonlyArray<T> {
    /// bunch of stuff
    // do not expose methods like push/splice which mutate array
    readonly length: number;
    readonly [n: number]: T;
}
```
3. we can make our own immutable objects/classes using technique above

### Gotchas

* excess property checks with object literals
Object literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error(object literal may specify only known properties)

* All things are structurally typed

Here is a big disucussion thread on github for nominal type support.
https://github.com/Microsoft/TypeScript/issues/202#issuecomment-329914167

* Modules

In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module. Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).

### String index signatures

here we’re saying a SquareConfig can have any number of properties, and as long as they aren’t color or width, their types don’t matter.

```ts
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

### Exhaustive checking with `never` type

`never` type represents something which is unreachable.
E.g. a funciton that always throws or is in an infinite loop
has a return type of never.

A switch case which covers all possible input also has `never` type 
in the default case.

```ts
type size = "L" | "M" |"S";

function neverAssertion(a: never): never{
    throw new Error(" a should be never but it is " + a);
}

function checkSizes(s: size) {
    switch(s) {
        case "L": return 10;
        case "M": return 20;
        // case "S": return 30;
        default: neverAssertion(s);// type error here until all cases of size are covered
    }
}
```

### Type Guards

A type guard is some expression that performs a runtime check that guarantees the type in some scope. Like narrowing of types in certain blocks of code, via control flow analysis.

#### User defined type guards

1. `type predicates`: We provide hint to compiler 
about type of a argument passed into a predicate function.

e.g.
```ts
// isFish is a type guard
// which when satisfied hints compiler that
// type is Fish inside type guarded block
function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;
}
```

2. `typeof` guard: `typeof` operator acts as a guard
by itself.
```ts
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        // padding is number here
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        // padding is string here
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
```

3. While typeof takes a string as argument and works on primitive types,
`instanceof` works with constructor functions(**not type or interfaces**)

```ts
interface Paddable {
    getPadding(): string;
}

class ABCElement implements Paddable {
    getPadding(){
        return "10";
    }
}

function testSomething(el: Paddable | string) {
    if (el instanceOf ABCElement) {
        // el  is ABCElement here
        console.log(el.getPadding());
    } else {
        // do something else
    }
}
```

### Enums

Enums are probably the most useful feature needed
e.g.
```ts
enum MediaType {
    JSON = 'application/json',
    HTML = 'text/html'
}

let mt: MediaType = MediaType.HTML;
```

`const enum` compiles differently (removes json object altogether and makes value inline in compiled version) than regular `enum`(preserves mapping).
There is also a compiler option `preserveConstEnums` to control this.

### Function signature overloads

### Interface vs `type`

One difference is that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for instance, error messages won’t use the alias name. In the code below, hovering over interfaced in an editor will show that it returns an Interface, but will show that aliased returns object literal type.

A second more important difference is that type aliases cannot be extended or implemented from (nor can they extend/implement other types)

### Literal types

Usually enums/disjoint union of values.
String literal types allow you to specify the exact value a string must have

### Indexed types

### Mapped types

### Conditional types

