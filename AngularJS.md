**AngularJS is Angular 1.x**

Beware that using `angular.module('myModule', [])` will create the module myModule and overwrite any existing module named myModule. Use `angular.module('myModule')` to retrieve an existing module.


## AngularJS history

1. AngularJS 1.2 - `controllerAs` + `this` introduced.
2. AngularJS 1.3 - `bindToController` boolean introduced to bind scope & controller for directives. `$validators` and `$asyncValidators` introduced.
3. AngularJS 1.4 - `bindToController` now is an object of shape of isolate scope field in ddo.
4. AngularJS 1.5 - `Component` introduced, `component` definitions are simpler
than directive and make transition to Angular 2 easier.

### Bootstrapping

AngularJS app is detected via attribute `ng-app`.
one can also optionally specify an angular module that
corresponds to the ng-app i.e. `<body ng-app="MyApp">...</body>`

### AngularJS module

An AngularJS module logically groups functionality as a single module.

In order to load an angular module for the first time, you need to  use `angular.module` as well as specify dependencies array.
e.g.
```js
// a.js
angular.module('MyApp', []);

// subsequent modifications to module, you should not specify
// dependencies
// b.js
angular.module('MyApp')
.controller('MyController', function(){
  // MyController code
});
```

### calling order

calling order:

1. `app.config()`
2. `app.run()`
3. directive's `compile` functions (if they are found in the dom)
4. `app.controller()`
5. directive's `link` functions (again, if found) (sets up watching exp etc)

```html
<div ng-app="myApp" ng-controller="myCtrl">
    <div test1 test2> </div>
</div>
```

```js
var myApp = angular.module('myApp', []);

myApp.factory('aProvider', function() {
   console.log("factory");
});

myApp.directive("test1", function() {
    console.log("directive setup");
    return {
        compile: function() {
        	console.log("directive compile test1");
        },
    }
});

myApp.directive("test2", function() {
    return {
        link: function() {
        console.log("directive link");
        }
    }
});

myApp.run(function() {
    console.log("app run");
});

myApp.config( function() {
    console.log("app config");
});

myApp.controller('myCtrl', function($scope) {
    console.log("app controller");
});
```

### Angularjs controller ($scope augmenter)

AngularJS, a controller is a JavaScript constructor function that is used to augment the AngularJS scope.

When a controller is attached to the DOM via the `ng-controller` directive, AngularJS will instantiate a new controller object, using the specified controller's constructor function. 

A new child scope will be available as an injectable parameter to the controller's constructor function as `$scope`


Scope is the glue between application controller and the view. During the template linking phase the directives set up `$watch` expressions on the scope. The `$watch` allows the directives to be notified of property changes, which allows the directive to render the updated value to the DOM.

Both controllers and directives have reference to the scope, but not to each other.

### AngularJS compilation process

```js
var $compile = ...; // injected into your code
var scope = ...;
var parent = ...; // DOM element where the compiled template can be appended

var html = '<div ng-bind="exp"></div>';

// Step 1: parse HTML into DOM element
var template = angular.element(html);

// Step 2: compile the template
// $compile: template => linkFn
var linkFn = $compile(template);

// Step 3: link the compiled template with the scope.
// linkFn: Scope => LiveElement
var element = linkFn(scope);

// Step 4: Append to DOM (optional)
parent.appendChild(element);
```

At this point you may wonder why the compile process has separate compile and link phases. The short answer is that compile and link separation is needed any time a change in a model causes a change in the structure of the DOM.

### Interpolate API and service

`$interpolate` is used.
`$interpolate: (StringWithBindings) => IntermediateExpression`
`IntermediateExpression: (contextValues) => string`, where string is final string that is generated by intrepolating bindings with contextValues.

e.g.
```js
var $interpolate = ...; // injected
var exp = $interpolate('Hello {{name | uppercase}}!');
expect(exp({name:'AngularJS'})).toEqual('Hello ANGULARJS!');
```

### Injectors in AngularJS

Services & Factories under the hood are created by providers. Even when we call angular.module(“somemodule”).service(), under the hood a provider is created which encapsulates the service code.

Two kinds
1. `Instance Injector`: Commonly used, what we perceive as `$injector`.
 This is the injector which is exposed and comes into play when controllers need access to a service. This is the thing which makes Dependency Injection possible. Caches instances

2. `Provider Injector`: Internally used injector. Caches Providers

### Getting the injector

Below we get the instance injector:
```js
var $injector = angular.injector();
```

### Useful methods on injector

1. `get: (name: string, [caller]) => any`
2. `invoke: (fn: function, [self], [locals]) => any`
3. `has: (name: string) => boolean`
4. `annotate: (fn: function, [strictdi]) => Array<string>`
5. `instantiate: (Type: function, [locals]) => Object`: Creates new instance of Type, i.e takes a constructor function, invokes new operator, and supplies all of args to constructor function

### The `$inject` property

If a function has a`$inject` property and it's value is an array
of strings,
then the strings represents names of services to be injected into
the function

```js
var MyController = function(obfScope, obfRoute){

}
MyController.$inject = ['$scope', '$route'];
expect(injector.annotate(MyController)).toEqual(['$scope', '$route'])
```

### AngularJS filters

#### Execution

If filter input is primitive, filter executed only when input has changed.
If filter input is object/s, filters are executed each `$digest`.

Also, filters that are marked as `$stateful`, are also executed on each digest.

The Filter filter is used for search.
e.g. searching for books
```js

<li ng-repeat="category in categories | filter: 'books'">
</li>
```

### angular.element

Wraps a raw DOM element or HTML string as a jQuery element.

If jQuery is available, `angular.element` is an alias for the jQuery function. If jQuery is not available, `angular.element` delegates to AngularJS's built-in subset of jQuery, called "jQuery lite" or `jqLite`.

**Note: Keep in mind that this function will not find elements by tag name / CSS selector. For lookups by tag name, try instead angular.element(document).find(...) or $document.find(), or use the standard DOM APIs, e.g. document.querySelectorAll().**

### Provider

The Provider recipe is syntactically defined as a custom type that implements a `$get` method. This method is a factory function just like the one we use in the Factory recipe. In fact, if you define a Factory recipe, an empty Provider type with the `$get` method set to your factory function is automatically created under the hood.

Provide any kind of values with provider.

Usually declaring providers instead of factories or services is overkill. The primary use case of provider is service/factory configuration before it is instantiated by injector.

### factories

A factory is a provider with less boilerplate.
Provide values like a provider with reduced boilerplate

### services

Service lets you return/provide a type/class/constructor function, not simplistic values.

The Service recipe produces a service just like the Value or Factory recipes, but it does so by invoking a constructor with the new operator. The constructor can take zero or more arguments, which represent dependencies needed by the instance of this type

```js
function UnicornLauncher(apiToken) {

  this.launchedCount = 0;
  this.launch = function() {
    // Make a request to the remote API and include the apiToken
    ...
    this.launchedCount++;
  }
}
// factory that returns an instance of UnicornLauncher type
myApp.factory('unicornLauncher', ["apiToken", function(apiToken) {
  return new UnicornLauncher(apiToken);
}]);
// equivalent service below
myApp.service('unicornLauncher', ["apiToken", UnicornLauncher]);
```

All services in AngularJS are singletons. That means that the injector uses each recipe at most once to create the object. The injector then caches the reference for all future needs.

https://www.youtube.com/watch?v=aqY5H95DZ8w

### configuration phase vs run phase

1. config phase
During application bootstrap, before AngularJS goes off creating all services, it configures and instantiates all providers. We call this the configuration phase of the application life-cycle. During this phase, services aren't accessible because they haven't been created yet.

2. run phase
Once the configuration phase is over, interaction with providers is disallowed and the process of creating services starts. We call this part of the application life-cycle the run phase.

### $scope.$apply, $scope.$watch and $scope.$digest

http://tutorials.jenkov.com/angularjs/watch-digest-apply.html

#### $scope.$apply

Execute a function in context of angularjs.
The `$scope.$apply()` function takes a function as parameter which is executed, and after that `$scope.$digest()` is called internally. That makes it easier for you to make sure that all watches are checked, and thus all data bindings refreshed.

#### $scope.$watch

`$watch(watchExpression, listener, [objectEquality]);`
`$scope.$watch` takes in two arguments, a `value function`, which should return an expression that is supposed to be watched, and a `listener function`, which will be executed whenever the value of the expression returned by value function changed.

```js
module.controller('CounterController', ['$scope' ,function($scope){
    $scope.count = 0;
    $scope.$watch(function($scope){// value fn -return expr to be watched
        return $scope.count;
    },function(newValue, oldValue){// listener function
        console.log('watch expression value changed! '+ oldValue + ' -> '+newValue);
    });
    // setTimeout is outside control of angularjs, put inside code
    // in a $apply
    setInterval(function(){
        $scope.$apply(function(){
            $scope.count = $scope.count + 5;
        });
    }, 1500);
}]);
```

The watchExpression is called on every call to `$digest()` and should return the value that will be watched. (watchExpression should not change its value when executed multiple times with the same input because it may be executed multiple times by `$digest()`. That is, watchExpression should be idempotent.)

The return value of `$watch` is a removal function.
A watch might remove itself in its own watch or listener fn i.e digest runs.
All watchers in a scope will effectively get removed once the scope is destroyed


#### $parse vs $compile

`$parse` takes in expressions and translates them to functions which can
take as arguments the `context/scope` in which to evaluate the expression.

`$compile` compiles an element and returns a link function,
which can be used to link scope.
Also this means that scope/context is not available at compilation time.

#### $scope.$eval

`$scope.$eval([expression], [locals])`: Evaluates
given expression(string or function), in the context of scope.
Also optional locals can be used in expression.
**Note**: Returns the result of expression evaluation.

e.g.
```js
$scope.a = 1;
$scope.b = 2;

expect($scope.$eval('a+b')).toBe(3);
expect($scope.$eval(function(sc){ return sc.a + sc.b; })).toBe(3);
```

**`$evalAsync`** : It takes a function to be executed,
and schedules to be executed later, but still in the ongoing digest.
Useful for deferring code from watch listeners.

Preferred over `$timeout`, since `$timeout` relinquishes control to browser.

**Note**: Althought `$evalAsync` triggers a digest,
It is advisable to use `$applyAsync` to execute such
code.

#### bindToController

A directive property (`true/false`).
Should have actually been named: bind isolate scope properties to controller.


#### $scope.$digest

The `$scope.$digest()` function iterates through all the watches in the `$scope` object, and its child `$scope` objects (if it has any). When `$digest()` iterates over the watches, it calls the value function for each watch. If the value returned by the value function is different than the value it returned the last time it was called, the listener function for that watch is called.

The `$digest()` function is called whenever AngularJS thinks it is necessary. For instance, after a button click handler has been executed, or after an AJAX call returns (after the `done()` / `fail()` callback function has been executed).

You may encounter some corner cases where AngularJS does not call the $digest() function for you. You will usually detect that by noticing that the data bindings do not upate the displayed values. In that case, call `$scope.$digest()` and it should work. Or, you can perhaps use `$scope.$apply()` instead which I will explain in the next section.

### $scope.$apply vs $scope.$digest

`$scope.$apply` starts running digests from the root scope.
where as `$scope.$digest` runs digest cycle on the scope it is called on, and its descendants.

`$scope.$apply` is used to integrate external code
with digest cycle. The reason for this is: `$apply` takes as its argument a function (which takes scope as its argument), runs that function via `$eval` followed by a `$digest`. This way non-angular can modify scope values and is digested by angularjs.

e.g. pseudo-code implementation of `$apply`:
```js
/**
* $apply: expr => any
* expr: (scope) => any
*/
function $apply(expr) {
  try {
    return $eval(expr);
  } catch (e) {
    $exceptionHandler(e);
  } finally {
    // note: digest starts at root scope.
    $root.$digest();
  }
}
```

**`$applyAsync`**: batch multiple expr given to apply in single digest.
Original motivation: If there are lot of HTTP responses at once, `$http`
service can be configured to use `$applyAsync` instead, in which case HTTP
response arriving very close to each other will be coalasced into a single
digest.

`$applyAsync` always defers execution. It never executes in the same digest cycle (supposing it is invoked in a listener function etc.)
Also the batching of effects in multiple `$applyAsync` are all combined inside one single `$apply`.


### custom directives

When should I use an attribute versus an element? Use an element when you are creating a component that is in control of the template. The common case for this is when you are creating a Domain-Specific Language for parts of your template. Use an attribute when you are decorating an existing element with new functionality.

#### Directive definition Object

The correct way to define custom directives,
Here is a sample that contains all possible fields:
```js
var myModule = angular.module(...);

myModule.directive('directiveName', function factory(injectables) {
  var directiveDefinitionObject = {
    priority: 0,
    template: '<div></div>', // or // function(tElement, tAttrs) { ... },
    // or
    // templateUrl: 'directive.html', // or // function(tElement, tAttrs) { ... },
    transclude: false,
    restrict: 'A',
    templateNamespace: 'html',
    scope: false,
    // SEAT
    controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... },
    controllerAs: 'stringAlias',
    require: 'siblingDirectiveName', // or // ['^parentDirectiveName', '?optionalDirectiveName', '?^optionalParent'],
    compile: function compile(tElement, tAttrs, transclude) {
      return {
        // SEAC
        pre: function preLink(scope, iElement, iAttrs, controller) { ... },
        post: function postLink(scope, iElement, iAttrs, controller) { ... }
      }
      // or
      // return function postLink( ... ) { ... }
    },
    // or
    // link: {
    //  pre: function preLink(scope, iElement, iAttrs, controller) { ... },
    //  post: function postLink(scope, iElement, iAttrs, controller) { ... }
    // }
    // or (most frequently used)
    // link: function postLink( ... ) { ... }
  };
  return directiveDefinitionObject;
});
```

#### scope option for custom directive

creates isolated scope for directive

1. If you specify true, it is a child scope (prototype inheritance)
2. but if you specify object or something else, it is an isolated scope.

#### Isolated scope parameters (@, =, &)

Communication between isolated scope and outside world

If `scope` property of DDO is set to {} (object hash), then a new "isolate" scope is created. The 'isolate' scope differs from normal scope in that it does not prototypically inherit from the parent scope. This is useful when creating reusable components, which should not accidentally read or modify data in the parent scope.

- `@` : bind a local scope property to the value of DOM attribute. The result is always a string since DOM attributes are strings. 

- `=` or `=attr`: set up bi-directional binding between a local scope property and the parent scope property of name defined via the value of the attr attribute.

- `&` or `&attr` - provides a way to execute an expression in the context of the parent scope.

#### link vs controller

Savvy readers may be wondering what the difference is between link and controller. The basic difference is that controller can expose an API, and link functions can interact with controllers using require.

Best Practice: use controller when you want to expose an API to other directives. Otherwise use link.

### Linking phase

The linking phase is where you attach the data ( $scope ) to the linking function and it should return you the linked html. Since the directive also specifies where this html goes or what it changes, it is already good to go. This is the function where you want to make changes to the linked html, i.e the html that already has the data attached to it. In angular if you write code in the linking function its generally the post-link function (by default). It is kind of a callback that gets called after the linking function has linked the data with the template.


### Transclusion

Transclusion is the process of extracting a collection of DOM element from one part of the DOM and copying them to another part of the DOM, while maintaining their connection to the original AngularJS scope from where they were taken.

Transclusion is used (often with ngTransclude) to insert the original contents of a directive's element into a specified place in the template of the directive. `The benefit of transclusion, over simply moving the DOM elements manually, is that the transcluded content has access to the properties on the scope from which it was taken, even if the directive has isolated scope`.
This makes it possible for the widget to have private state for its template, while the transcluded content has access to its originating scope.

When `transclude` property is true in DDO,
transclusion function is provided to controller and link function.

Possible values of `transclude`:
1. true
2. `element`: This causes the element itself to be transcluded (e.g. in `ng-repeat`), so it becomes the responsibility of the link function to add it to the dom now.

https://stackoverflow.com/questions/18449743/when-to-use-transclude-true-and-transclude-element-in-angular


This transclusion function is a special linking function that will return the compiled contents linked to a new transclusion scope.

When to use transclusion function?
If you are just using ngTransclude then you don't need to worry about this function, since ngTransclude will deal with it for us.
If you want to manually control the insertion and removal of the transcluded content in your directive then you must use this transclude function. When you call a transclude function it returns a a jqLite/JQuery object that contains the compiled DOM, which is linked to the correct transclusion scope.


### Firing events in angular

`$emit` fires upwards w.r.t scope.
`$broadcast` fires downwards w.r.t scope

```js
// firing an event upwards
$scope.$emit('myCustomEvent', 'Data to send');

// firing an event downwards
$scope.$broadcast('myCustomEvent', {
  someProp: 'Sending you an Object!' // send whatever you want
});

// listen for the event in the relevant $scope
$scope.$on('myCustomEvent', function (event, data) {
  console.log(data); // 'Data to send'
});
```

#### firing events with `$scope`

The key thing to remember when using $scope to fire your events, is that they will communicate only with descendant parent or child scopes only! Scopes aren’t always child and parent. We might have sibling scopes. Using $scope to fire an event will miss out sibling scopes, and just carry on up! 

#### rootScope broadcast and rootScope emit

The $rootScope Object has the identical $emit, $broadcast, $on methods, but they work slightly differently to how $scope implements them. 

As $rootScope has no $parent, using an $emit would be pointless, right? Nope, instead, `$rootScope.$emit` will fire an event for all `$rootScope.$on` listeners only. The interesting part is that `$rootScope.$broadcast` will notify all `$rootScope.$on` as well as `$scope.$on` listeners, subtle but very important difference if you want to avoid issues in your application.

#### Unsubscribing on destroy

```js
app.controller('ParentCtrl',
  function ParentCtrl ($scope) {

  // $rootScope $on
  var myListener = $rootScope.$on('child', function (event, data) {
    //
  });

  // $scope $destroy
  $scope.$on('$destroy', myListener);

});
```

### AngularJS Controller As syntax

Pre v1.2 controllers
```js
// <div ng-controller="MainCtrl"></div>
app.controller('MainCtrl', function ($scope) {
  $scope.title = 'Some title';
});
```

New way: (Also known as namespacing stuff)
We use controller as varname with `this` in controller constructor function.

```html
<div ng-controller="MainCtrl as main">
  // MainCtrl doesn't exist, we get the `main` instance only
  {{main.title}}
</div>
```
```js
// we declare as usual, just using the `this` Object instead of `$scope`
app.controller('MainCtrl', function () {
  this.title = 'Some title';
});
```

### $q service

#### $q.when

Calling `$q.when` takes a promise or any other type, if it is not a promise then it will wrap it in a promise and call resolve. If you pass a value to it then it is never going to be rejected.

`$q.resolve` is an alias for `$q.when` for consistency with Es6's `Promise.resolve`.

### AngularJS components

Main intent : combine a controller with template.
Easier form/standardization for specifying directives.
Isolate scoped by default.
1. using `this` for model. ditching `$scope` variable name
2. using `$ctrl` for controller scope.
3. Can be only used as html elements.
4. components do not have link functions, they have lifecycle hooks.

#### Defining a component
Note the definition takes an object  and not a function.

```js
myModule.component('myComponent', {
  template: "...",
  bindings: { /* ... */ },
  controller: function(){ /* ... */ },
});
```

### routing in angularjs (ngRoute & $route)

If you want to navigate to different pages in your application, but you also want the application to be a SPA (Single Page Application), with no page reloading, you can use the `ngRoute` module.

The `ngRoute` module routes your application to different pages without reloading the entire application.

Routing does not come out of the box and we need an external script to use it i.e.
```html
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.9/angular-route.js"></script>
```

In order to use routing features, we must add `ngRoute` as a dependency of our app. i.e.
```js
var app = angular.module("myApp", ["ngRoute"]);
```

Setting up routing:
1. specify routes via `$routeProvider` in `app.config`.
2. The UI where routes are shown are `ng-view` e.g. `<div ng-view></div>`.

```js
var app = angular.module("myApp", ["ngRoute"]);
app.config(function($routeProvider) {
    $routeProvider
    .when("/", {
        templateUrl : "main.htm"
    })
    .when("/london", {
        templateUrl : "london.htm",
        controller : "londonCtrl"
    })
    .when("/paris", {
        templateUrl : "paris.htm",
        controller : "parisCtrl"
    });
});
app.controller("londonCtrl", function ($scope) {
    $scope.msg = "I love London";
});
app.controller("parisCtrl", function ($scope) {
    $scope.msg = "I love Paris";
});
```

### routing via ui-router library

UI-Router is a state based routing library:

1. State - Each state is described by a) URL, b) name c) data d) UI and other pre requeisites (e.g. auth)

Before activating a state, UI-Router first fetches any prerequisites (asynchronously), and then activates the view(s) and updates the URL.

UI-Router states are hierarchical; states can be nested inside other states, forming a tree.
Child states may inherit data and behavior (such as authentication) from their parent states.

2. View - A view is a UI component that is placed in a viewport(`ui-view`),
when state is activated.

A named view can target an arbitrary viewport, anywhere in the DOM (even outside the component hierarchy of the parent state). This can be used to fill (or override) named viewports such as footers, or nagivation, when some nested state is active.

Where does the template get inserted?
When a state is activated, its templates are automatically inserted into the `ui-view` of its parent state's template. If it's a top-level state—which 'contacts' is because it has no parent state–then its parent template is `index.html`.

3. URL - A state can define a URL, but it isn’t required. If a state has defined a URL, the browser’s location is updated to that URL when the state is active.

A state’s URL is actually a URL fragment. Each state defines only the fragment (portion) of the URL that it “owns”.

4. Parameters:

A state can be parameterized, the parameters can be sent in path, in query params or programmatically without showing up in URL.

- **Path**: in the URL's path: `/foo/{fooId}` matches '123' in `http://mysite.com/foo/123`
- **Query**: in the URL's query string: `/foo?fooId` matches '123' in `http://mysite.com/foo?fooId=123`
- **Non-url**: arbitrary parameter data may be passed programmatically, and not reflect in the URL

Parameters can be typed. Typed parameters are encoded as strings in the URL, but are converted to a native type when retrieved in javascript code. There are a few built in parameter types: string, int, bool, date, json.

The `$transition$` is a special injectable object with information about the current state transition.

e.g.
```js
{
  name: 'person',
  url: '/people/{personId}',
  component: 'person', // instead of template
  resolve: {
    person: function(PeopleService, $transition$) {
      return PeopleService.getPerson($transition$.params().personId);
    }
  }
}
```

To pass parameters to a state using ui-sref, add parenthesis after the state name.
An expression string inside the parenthesis is used as the target state parameter key/value pairs. The expression is evaluated against the enclosing scope.
e.g
```html
  <li ng-repeat="person in $ctrl.people">
    <a ui-sref="person({ personId: person.id })">
      {{person.name}}
    </a>
  </li>
```


5. Resolve data

When a user switches back and forth between states of a single page web app, the app often needs to fetch application data from a server API, such as a REST endpoint.

A state can specify the data it requires by using a resolve: block. When the user tries to activate a state which has a resolve: block, UI-Router will fetch the required data before activating the state.

An AngularJS (1.x) resolve: block is an object on a state definition. Each key is the name of some data to load, and each value is a function which returns a promise for the data.

When fetching data, we recommend delegating to services which return promises.

e.g.
```js
var peopleState = {
  name: 'people',
  url: '/people',
  component: 'people',
  resolve: {
    people: function(PeopleService) {
      return PeopleService.getAllPeople();
    }
  }
};
```

6. Transitions:

Transitions between states are transaction-like, i.e., they either completely succeed or completely fail.

Lifecycle: transitions have a well defined lifecycle
1. before: before the asyc portion of a transition has begun
2. start: the transition has begun
3. exit: the transition is exiting states
4. retain: states are retained (a state was active, and is neither being exited nor entered)
5. enter: the transition is entering states
6. finish: the transition is finishing
7. success/error: after the transition is complete


Transition Lifecycle Hooks:
Hooks may be registered for any stage of the transition lifecycle.
Hooks can alter the transition:
* pause the transition, waiting on some promise
* cancel the transition
* redirect the transition to a new target state

match criteria:
A hook can choose which transitions it should be applied to.
* to/from: only run the hook if the transition is going to or coming from a specific state
* entering/exiting: only run the hook if the transition is going to enter or exit a specific state

criteria types:
* state name: the hook’s match criteria can be state names, such as banking.account
* glob: the criteria can be a state glob pattern, such ash banking.**
* callback: the criteria can be a callback function, such as tostate => tostate.data.requiresAuth == true

### Using `$state`

#### `$state.go(stateName)`

Programmatically jump to Absolute State Name or Relative State Path with `$state.go(stateName)`
Returns a Promise representing the state of the transition.

e.g.
```js
$state.go('about');// jumps to about state
```

`$state.go` internally calls `$state.transitionTo` which is a lower
level method.

Absolute State Name or Relative State Path.
The name of the state that will be transitioned to or a relative state path. If the path starts with `^` or `.` then it is relative, otherwise it is absolute.

Some examples:
```js
$state.go('contact.detail') will go to the 'contact.detail' state
$state.go('^') will go to a parent state.
$state.go('^.sibling') will go to a sibling state.
$state.go('.child') will go to a child state.
$state.go('.child.grandchild') will go to a grandchild state.
```

### `ui-sref`

A directive that binds a link (`<a>` tag) to a state. If the state has an associated URL, the directive will automatically generate & update the href attribute.

Usage:

`ui-sref='stateName'` - Navigate to state, no params. 'stateName' can be any valid absolute or relative state, following the same syntax rules as $state.go()
`ui-sref='stateName({param: value, param: value})'` - Navigate to state, with params.

e.g.
```html
<a ui-sref="home">Home</a> | <a ui-sref="about">About</a>

<ul>
    <li ng-repeat="contact in contacts">
        <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
    </li>
</ul>
```

The parameters in url are available to component
using `$stateParams`.

### $stateParams service

Used to access params present in url/state.

### Angularjs Material

Dialogs are managed by something known as interim
element that deals with promises

https://github.com/angular/material/blob/master/src/core/services/interimElement/interimElement.js

`show` returns a promise that will be resolved/rejected when interim element is hidden/cancelled.

In this terminology hide means returning some data resolving on closing dialog.
And cancel means rejecting on closing dialog

